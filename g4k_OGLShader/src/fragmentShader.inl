//--------------------------------------------------------------------------//
// iq / rgba  .  tiny codes  .  2008/2021                                   //
//--------------------------------------------------------------------------//

static const char* fragmentShader = \
"#version 430\n"
"uniform float iGlobalTime;"
"varying vec2 fragCoord;"
"mat3 rotate_x(float a)"
"{"
"float sa=sin(a);"
"a=cos(a);"
"return mat3(vec3(1,0,0),vec3(0,a,sa),vec3(0,-sa,a));"
"}"
"vec3 mandelboxPosition;\n"
"#define BPM 119.\n"
"#define BPS (60./BPM)\n"
"#define DEL -0.00\n"
"float revsaw(float beats)"
"{"
"beats*=BPS;"
"return smoothstep(0.,1.,1.-mod(iGlobalTime-DEL,beats)/beats);"
"}"
"float square()"
"{"
"float beats=32.*BPS;"
"return mod(iGlobalTime-DEL,beats)/beats<.5?"
"0.:"
"1.;"
"}"
"float sdTorus(vec3 p)"
"{"
"vec2 t=vec2(6,2.5);"
"return length(vec2(length(p.xz)-t.x,p.y))-t.y;"
"}"
"float sdBox(vec3 p,vec3 b)"
"{"
"p=abs(p)-b;"
"return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);"
"}"
"vec3 repeat(vec3 pos,vec3 s)"
"{"
"return pos-s*round(pos/s);"
"}"
"float opSubtraction(float d1,float d2)"
"{"
"return max(d1,-d2);"
"}"
"void sphereFold(inout vec3 z,inout float dz)"
"{"
"float r2=dot(z,z);"
"if(r2<1.7)"
"{"
"float temp=1.7/r2;"
"z*=temp;"
"dz*=temp;"
"}"
"}"
"void boxFold(inout vec3 z,inout float dz)"
"{"
"z=clamp(z,-1.,1.)*2.-z;"
"}\n"
"#define MX 13\n"
"float mandelbox_de(vec3 z)"
"{"
"mandelboxPosition=z;"
"float Scale=-.85-sin(iGlobalTime*.002)*.45;"
"vec3 offset=z;"
"float dr=20.;"
"for(int n=0;n<MX;n++)"
"boxFold(z,dr),sphereFold(z,dr),z=Scale*z+offset,dr=dr*abs(Scale)+1.;"
"Scale=length(z);"
"return Scale/abs(dr);"
"}"
"float scene(vec3 pos)"
"{"
"float d1=mandelbox_de((pos+vec3(30,cos(iGlobalTime*.0025)*30.,1))*(sin(iGlobalTime*.025)+1.5)*.025);"
"d1=min(opSubtraction(d1,sdTorus(pos)),length(repeat(pos+vec3(sin(iGlobalTime)*1.6,1.5,cos(iGlobalTime)*1.6),vec3(6,5,6)))-.7);"
"vec3 bsize=vec3(6,6,2)*(1.5-square()*.5);"
"return opSubtraction(d1,sdBox(repeat(vec3(0,0,5.*sin(iGlobalTime*.1))+pos*rotate_x(iGlobalTime*.1),vec3(10)),bsize));"
"}"
"vec3 calcNormal(vec3 pos)"
"{"
"vec2 e=vec2(1,-1)*.5773;"
"return normalize(e.xyy*scene(pos+e.xyy*5e-4)+e.yyx*scene(pos+e.yyx*5e-4)+e.yxy*scene(pos+e.yxy*5e-4)+e.xxx*scene(pos+e.xxx*5e-4));"
"}\n"
"#define HS .1031\n"
"float hash(float p)"
"{"
"vec3 p3=fract(vec3(p)*HS);"
"p3+=dot(p3,p3.yzx+19.19);"
"return fract((p3.x+p3.y)*p3.z);"
"}"
"float ambientOcclusion(vec3 p,vec3 n)"
"{"
"float ao=0.;"
"for(int i=0;i<10;i++)"
"{"
"float l=hash(float(i))*2.5;"
"ao+=(l-max(scene(p+n*l),0.))/2.5*2.5;"
"}"
"return clamp(1.-ao/float(10),.05,1.);"
"}"
"vec3 stripes(vec3 pos)"
"{"
"float stripe=sin(pos.x*7.)*.4+.6;"
"return vec3(1,stripe,stripe*.75);"
"}"
"float ribbonscene(vec3 p)"
"{"
"float size=revsaw(1.)*.05+.05;"
"return min(min(sdBox(p+vec3(3.*sin(iGlobalTime*.2)+cos(p.z),-sin(p.z),15.*cos(iGlobalTime*.25)),vec3(size,size,4)),sdBox(p+vec3(3.*sin(iGlobalTime*.2)+cos(p.z),sin(p.z),-4.+15.*sin(iGlobalTime*.25)),vec3(size,size,4))),sdBox(p+vec3(3.*sin(iGlobalTime*.2)+cos(p.z),4.-sin(p.z),-8.+15.*sin(iGlobalTime*.25)),vec3(size,size,4)));"
"}"
"vec4 ribbons(vec3 rd,vec3 ro,float boxDepth)"
"{"
"float t=0.;"
"vec3 pos;"
"for(int i=0;i<64;i++)"
"{"
"pos=ro+t*rd;"
"float h=ribbonscene(pos);"
"if(h<1e-4)"
"break;"
"else if(t>15.)"
"break;"
"t+=h;"
"}"
"if(t<15.&&t<boxDepth)"
"{"
"float val=1.-t*.05;"
"return vec4(0,val,val,1);"
"}"
"return vec4(0);"
"}"
"void main()"
"{"
"vec2 iResolution = vec2(1280.,720.);"
"vec2 p=(-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;"
"float an=.05*iGlobalTime+sin(iGlobalTime*.1)*p.y*sin(iGlobalTime*.05)*2.;"
"an*=square()*2.-1.;"
"vec3 ro=vec3(8.*cos(an),.6,8.*sin(an)),ww=normalize(vec3(0,sin(iGlobalTime*.5),0)-ro),uu=normalize(cross(ww,vec3(0,.6,.5)));"
"uu=normalize(p.x*uu+p.y*normalize(cross(uu,ww))+1.5*ww);"
"an=0.;"
"float ribsDist=1e5;"
"for(int i=0;i<128;i++)"
"{"
"ww=ro+an*uu;"
"float h=scene(ww);"
"if(h<.00015)"
"{"
"ribsDist=ribbonscene(ww);"
"break;"
"}"
"else if(an>35.)"
"break;"
"an+=h;"
"}"
"vec3 col=vec3(0);"
"if(an<35.)"
"{"
"vec3 nor=calcNormal(ww);"
"float dif=clamp(dot(nor,vec3(.7,1.2,.4)),0.,1.2);"
"dif*=dif;"
"dif*=dif;"
"dif*=revsaw(16.);"
"float amb=.5+.5*dot(nor,vec3(0,.8,-.6));"
"amb*=revsaw(16.);"
"col=vec3(.2,.3,.5)*amb+stripes(mandelboxPosition)*vec3(.9,.8,.6)*dif;"
"col*=ambientOcclusion(ww,nor);"
"if(ribsDist<2.)"
"{"
"float f=(2.-ribsDist)/2.;"
"col+=f*f*f*vec3(0,1,1)*(revsaw(1.)*.5+.5);"
"}"
"col/=max(1.,ww.z*.5);"
"}"
"col=sqrt(col);"
"col = col*0.5 + 0.5*col*col*(3.0-2.0*col);"
"vec4 ribs=ribbons(uu,ro,an);"
"gl_FragColor=vec4(col,0.)+ribs;"
"}";