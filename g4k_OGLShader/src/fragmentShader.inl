//--------------------------------------------------------------------------//
// iq / rgba  .  tiny codes  .  2008/2021                                   //
//--------------------------------------------------------------------------//

static const char* fragmentShader = \
"#version 430\n"
"uniform float iGlobalTime;"
"mat3 rotate_x(float a)"
"{"
"float sa=sin(a);"
"a=cos(a);"
"return mat3(vec3(1,0,0),vec3(0,a,sa),vec3(0,-sa,a));"
"}"
"vec3 mandelboxPosition;\n"
"#define BPM 119.\n"
"#define BPS (60./BPM)\n"
"#define DEL 0.\n"
"#define TT iGlobalTime-DEL\n"
"float revsaw(float beats)"
"{"
"beats*=BPS;"
"return smoothstep(0.,1.,1.-mod(TT,beats)/beats);"
"}"
"float square()"
"{"
"float beats=32.*BPS;"
"return mod(TT,beats)/beats<.5?"
"0.:"
"1.;"
"}"
"float beatstep(float beats)"
"{"
"beats*=BPS;"
"return TT<beats?"
"0.:"
"1.;"
"}"
"float sdTorus(vec3 p,vec2 t)"
"{"
"return length(vec2(length(p.xz)-t.x,p.y))-t.y;"
"}"
"float sdBox(vec3 p,vec3 b)"
"{"
"p=abs(p)-b;"
"return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);"
"}"
"vec3 repeat(vec3 pos,vec3 s)"
"{"
"return pos-s*round(pos/s);"
"}"
"float opSubtraction(float d1,float d2)"
"{"
"return max(d1,-d2);"
"}"
"void sphereFold(inout vec3 z,inout float dz)"
"{"
"float r2=dot(z,z);"
"if(r2<1.7)"
"{"
"float temp=1.7/r2;"
"z*=temp;"
"dz*=temp;"
"}"
"}"
"void boxFold(inout vec3 z,inout float dz)"
"{"
"z=clamp(z,-1.,1.)*2.-z;"
"}"
"float mandelbox_de(vec3 z)"
"{"
"mandelboxPosition=z;"
"float Scale=-.85-sin(iGlobalTime*.002)*.45;"
"vec3 offset=z;"
"float dr=20.;"
"for(int n=0;n<13;n++)"
"boxFold(z,dr),sphereFold(z,dr),z=Scale*z+offset,dr=dr*abs(Scale)+1.;"
"Scale=length(z);"
"return Scale/abs(dr);"
"}"
"float scene(vec3 pos)"
"{"
"float d1=mandelbox_de((pos+vec3(30,cos(iGlobalTime*.0025)*30.,1))*(sin(iGlobalTime*.025)+1.5)*.025),size1=6.+beatstep(140.)*2.,size2=2.5+beatstep(128.)*3.-beatstep(140.)*2.;"
"d1=min(opSubtraction(d1,sdTorus(pos,vec2(size1,size2))),length(repeat(pos+vec3(sin(iGlobalTime)*1.6,1.5,cos(iGlobalTime)*1.6),vec3(6,5,6)))-.7);"
"vec3 bsize=vec3(6,6,2)*(1.5-square()*.5);"
"return opSubtraction(d1,sdBox(repeat(vec3(0,0,5.*sin(iGlobalTime*.1))+pos*rotate_x(iGlobalTime*.1),vec3(10)),bsize));"
"}"
"vec3 calcNormal(vec3 pos)"
"{"
"vec2 e=vec2(1,-1)*.5773;"
"return normalize(e.xyy*scene(pos+e.xyy*5e-4)+e.yyx*scene(pos+e.yyx*5e-4)+e.yxy*scene(pos+e.yxy*5e-4)+e.xxx*scene(pos+e.xxx*5e-4));"
"}"
"float hash(float p)"
"{"
"vec3 p3=fract(vec3(p)*.1031);"
"p3+=dot(p3,p3.yzx+19.19);"
"return fract((p3.x+p3.y)*p3.z);"
"}"
"float ambientOcclusion(vec3 p,vec3 n)"
"{"
"float ao=0.;"
"for(int i=0;i<9;i++)"
"{"
"float l=hash(float(i))*2.5;"
"ao+=(l-max(scene(p+n*l),0.))/2.5*2.5;"
"}"
"return clamp(1.-ao/9.,.05,1.);"
"}"
"vec3 stripes(vec3 pos)"
"{"
"float stripe=sin(pos.x*7.)*.4+.6;"
"return vec3(1,stripe,stripe*.75);"
"}"
"int numRibbons()"
"{"
"return 4+int(beatstep(128.))*3;"
"}"
"int numRibbonStacks()"
"{"
"return 1+int(beatstep(124.))*4-int(beatstep(160.))*3;"
"}"
"float ribbonSpacing()"
"{"
"return 6.-beatstep(124.)*2.5;"
"}"
"vec3 ribbonColor(float n)"
"{"
"return vec3(mod(n,7.)/14.,mod(n,5.)/5.,.5+mod(n,3.)/6.);"
"}"
"vec2 ribbonscene(vec3 p)"
"{"
"float size=revsaw(1.)*.05+.05+beatstep(120.)*.05,d=1e4,ld=d,ribbonStart=float(-numRibbons())*ribbonSpacing()/2.+6.,n=0.;"
"for(int i=0;i<numRibbons();++i)"
"{"
"float fi=float(i);"
"for(int j=0;j<numRibbonStacks();++j)"
"{"
"float fj=float(j+1);"
"d=min(d,sdBox(p+vec3(fj*ribbonSpacing()+3.*sin(iGlobalTime*.2*fj)+cos(p.z*.5),ribbonStart+ribbonSpacing()*fi+sin(p.z*.5),ribbonStart+fi*ribbonSpacing()*2.*sin(iGlobalTime*.25*fj)),vec3(size,size,4.+beatstep(120.)*6.)));"
"if(d<ld)"
"n=float(numRibbonStacks())*fj+fi,ld=d;"
"}"
"}"
"return vec2(d,n);"
"}"
"vec3 ribbons(vec3 rd,vec3 ro,float boxDepth)"
"{"
"float t=0.;"
"vec3 pos;"
"float n=0.;"
"for(int i=0;i<64;i++)"
"{"
"pos=ro+t*rd;"
"vec2 ribbonResult=ribbonscene(pos);"
"float h=ribbonResult.x;"
"if(h<1e-4)"
"{"
"n=ribbonResult.y;"
"break;"
"}"
"else if(t>15.)"
"break;"
"t+=h;"
"}"
"return t<15.&&t<boxDepth?"
"ribbonColor(n):"
"vec3(0);"
"}"
"void main()"
"{"
"vec2 ir=vec2(1280,720);"
"ir=(-ir.xy+2.*gl_FragCoord.xy)/ir.y;"
"float an=.05*iGlobalTime+sin(iGlobalTime*.1)*ir.y*sin(iGlobalTime*.05)*2.;"
"an*=square()*2.-1.;"
"vec3 ro=vec3(8.*cos(an),.6,8.*sin(an)),ww=normalize(vec3(0,sin(iGlobalTime*.5),0)-ro),uu=normalize(cross(ww,vec3(0,.6,.5)));"
"ww=normalize(ir.x*uu+ir.y*normalize(cross(uu,ww))+1.5*ww);"
"an=0.;"
"float ribsDist=1e5,n=0.;"
"for(int i=0;i<128;i++)"
"{"
"uu=ro+an*ww;"
"float h=scene(uu);"
"if(h<.00015)"
"{"
"vec2 ribResult=ribbonscene(uu);"
"ribsDist=ribResult.x;"
"n=ribResult.y;"
"break;"
"}"
"else if(an>35.)"
"break;"
"an+=h;"
"}"
"vec3 col=vec3(0);"
"if(an<35.)"
"{"
"vec3 nor=calcNormal(uu);"
"float dif=clamp(dot(nor,vec3(.7,1.2,.4)),0.,1.2);"
"dif*=dif;"
"dif*=dif;"
"dif*=revsaw(16.);"
"float amb=.5+.5*dot(nor,vec3(0,.8,-.6));"
"amb*=revsaw(16.);"
"col=vec3(.2,.3,.5)*amb+stripes(mandelboxPosition)*vec3(.9,.8,.6)*dif;"
"col*=ambientOcclusion(uu,nor);"
"if(ribsDist<2.)"
"{"
"float f=(2.-ribsDist)/2.;"
"col+=f*f*f*ribbonColor(n)*(revsaw(1.)*.5+.5);"
"}"
"col/=max(1.,uu.z*.5);"
"}"
"col=sqrt(col);"
"col=col*.5+.5*col*col*(3.-2.*col);"
"ro=ribbons(ww,ro,an);"
"gl_FragColor=vec4(col,an)+vec4(ro,0);"
"}";